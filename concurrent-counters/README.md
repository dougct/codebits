# Benchmark results

```
----------------------------------------------------------------------------------------------------------
Benchmark                                                Time             CPU   Iterations UserCounters...
----------------------------------------------------------------------------------------------------------
BM_ExactCounterSingleThreaded                         9.00 ns         9.00 ns     77513371 items_per_second=111.158M/s
BM_ExactCounterMultiThreaded/8/real_time              2350 ns         2327 ns       291285 items_per_second=3.40497M/s
BM_ExactCounterMultiThreaded/16/real_time             2457 ns         2429 ns       286113 items_per_second=6.5113M/s
BM_ApproxCounterSingleThreaded                        17.1 ns         17.1 ns     40482786 items_per_second=58.4054M/s
BM_ApproxCounterMultiThreaded/8/1024/real_time        2346 ns         2323 ns       297551 items_per_second=3.41029M/s
BM_ApproxCounterMultiThreaded/16/1024/real_time       2509 ns         2469 ns       284297 items_per_second=6.37694M/s
```

# Notes

Version of `update` with a bug:

```cpp
// All variables are atomic
int64_t update(int64_t amount) {
    // Round-robin updating local counters
    const uint32_t idx = num_updates_++ % num_threads_;
    local_counters_[idx] += amount;
    if (num_updates_ >= threshold_) {
        global_counter_ += local_counters_[idx];
        local_counters_[idx] = 0;
        num_updates_ = 0;
    }
    return global_counter_;
}
```

This version was overcounting in the ApproxCounter because even though the increments are atomic, there could be some thread interleavings which lead to double counting.

Let's analyze this code using Spin. I created an equivalent version of the code above in Promela:

```
#define NUM_THREADS 2    /* Assuming some number of threads */
#define THRESHOLD 2     /* Assuming some threshold value */

/* Global variables */
int global_counter = 0;
byte local_counters[NUM_THREADS];
byte num_updates = 0;

proctype counter_process(byte amount) {
    byte idx;

    idx = num_updates % NUM_THREADS;
    num_updates = num_updates + 1;

    local_counters[idx] = local_counters[idx] + amount;

    if
    :: (num_updates >= THRESHOLD) ->
        global_counter = global_counter + local_counters[idx];
        local_counters[idx] = 0;
        num_updates = 0;
    :: else -> skip
    fi;
}

init {
    byte i;
    for (i : 1 .. 10) {
        atomic {
            run counter_process(1);
            run counter_process(1);
        }
    }
    (_nr_pr == 1) -> printf("global_counter = %d\n", global_counter)
    assert (global_counter <= 20)
}
```

Here's the trace generated by Spin showing that we can indeed overcount if we use the code above:

```
  1:    proc  0 (:init::1) update.pml:41 (state 1)      [i = 1]
  2:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 1
  3:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 2
  4:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
  5:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
  6:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 3
  7:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 4
  8:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
  9:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 10:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 5
 11:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 6
 12:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 13:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 14:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 7
 15:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 8
 16:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 17:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 18:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 9
 19:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 10
 20:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 21:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 22:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 11
 23:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 12
 24:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 25:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 26:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 13
 27:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 14
 28:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 29:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 30:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 15
 31:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 16
 32:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 33:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 34:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 17
 35:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 18
 36:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 37:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 38:    proc  0 (:init::1) update.pml:41 (state 2)      [((i<=10))]
Starting counter_process with pid 19
 39:    proc  0 (:init::1) update.pml:43 (state 3)      [(run counter_process(1))]
Starting counter_process with pid 20
 40:    proc  0 (:init::1) update.pml:44 (state 4)      [(run counter_process(1))]
 41:    proc  0 (:init::1) update.pml:41 (state 6)      [i = (i+1)]
 42:    proc  0 (:init::1) update.pml:46 (state 7)      [else]
 43:    proc 20 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 44:    proc 20 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 45:    proc 20 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 46:    proc 20 (counter_process:1) update.pml:35 (state 8)     [else]
 47:    proc 20 (counter_process:1) update.pml:35 (state 9)     [(1)]
 48: proc 20 terminates
 49:    proc 19 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 50:    proc 19 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 51:    proc 19 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 52:    proc 19 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
 53:    proc 19 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
 54:    proc 19 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
 55:    proc 19 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
 56: proc 19 terminates
 57:    proc 18 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 58:    proc 18 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 59:    proc 18 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 60:    proc 18 (counter_process:1) update.pml:35 (state 8)     [else]
 61:    proc 18 (counter_process:1) update.pml:35 (state 9)     [(1)]
 62: proc 18 terminates
 63:    proc 17 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 64:    proc 17 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 65:    proc 17 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 66:    proc 17 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
 67:    proc 17 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
 68:    proc 17 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
 69:    proc 17 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
 70: proc 17 terminates
 71:    proc 16 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 72:    proc 16 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 73:    proc 16 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 74:    proc 16 (counter_process:1) update.pml:35 (state 8)     [else]
 75:    proc 16 (counter_process:1) update.pml:35 (state 9)     [(1)]
 76: proc 16 terminates
 77:    proc 15 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 78:    proc 15 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 79:    proc 15 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 80:    proc 15 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
 81:    proc 15 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
 82:    proc 15 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
 83:    proc 15 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
 84: proc 15 terminates
 85:    proc 14 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 86:    proc 14 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 87:    proc 14 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 88:    proc 14 (counter_process:1) update.pml:35 (state 8)     [else]
 89:    proc 14 (counter_process:1) update.pml:35 (state 9)     [(1)]
 90: proc 14 terminates
 91:    proc 13 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
 92:    proc 13 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
 93:    proc 13 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
 94:    proc 13 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
 95:    proc 13 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
 96:    proc 13 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
 97:    proc 13 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
 98: proc 13 terminates
 99:    proc 12 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
100:    proc 12 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
101:    proc 12 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
102:    proc 12 (counter_process:1) update.pml:35 (state 8)     [else]
103:    proc 12 (counter_process:1) update.pml:35 (state 9)     [(1)]
104: proc 12 terminates
105:    proc 11 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
106:    proc 11 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
107:    proc 11 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
108:    proc 11 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
109:    proc 11 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
110:    proc 11 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
111:    proc 11 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
112: proc 11 terminates
113:    proc 10 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
114:    proc 10 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
115:    proc 10 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
116:    proc 10 (counter_process:1) update.pml:35 (state 8)     [else]
117:    proc 10 (counter_process:1) update.pml:35 (state 9)     [(1)]
118: proc 10 terminates
119:    proc  9 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
120:    proc  9 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
121:    proc  9 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
122:    proc  9 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
123:    proc  9 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
124:    proc  9 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
125:    proc  9 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
126: proc 9 terminates
127:    proc  8 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
128:    proc  8 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
129:    proc  8 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
130:    proc  8 (counter_process:1) update.pml:35 (state 8)     [else]
131:    proc  8 (counter_process:1) update.pml:35 (state 9)     [(1)]
132: proc 8 terminates
133:    proc  7 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
134:    proc  7 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
135:    proc  7 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
136:    proc  7 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
137:    proc  7 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
138:    proc  7 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
139:    proc  7 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
140: proc 7 terminates
141:    proc  6 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
142:    proc  6 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
143:    proc  6 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
144:    proc  6 (counter_process:1) update.pml:35 (state 8)     [else]
145:    proc  6 (counter_process:1) update.pml:35 (state 9)     [(1)]
146: proc 6 terminates
147:    proc  5 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
148:    proc  5 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
149:    proc  5 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
150:    proc  5 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
151:    proc  5 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
152:    proc  5 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
153:    proc  5 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
154: proc 5 terminates
155:    proc  4 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
156:    proc  4 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
157:    proc  4 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
158:    proc  4 (counter_process:1) update.pml:35 (state 8)     [else]
159:    proc  4 (counter_process:1) update.pml:35 (state 9)     [(1)]
160: proc 4 terminates
161:    proc  3 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
162:    proc  3 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
163:    proc  3 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
164:    proc  3 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
165:    proc  3 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
166:    proc  3 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
167:    proc  3 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
168: proc 3 terminates
169:    proc  2 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
170:    proc  1 (counter_process:1) update.pml:25 (state 1)     [idx = (num_updates%2)]
171:    proc  2 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
172:    proc  2 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
173:    proc  1 (counter_process:1) update.pml:26 (state 2)     [num_updates = (num_updates+1)]
174:    proc  2 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
175:    proc  2 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
176:    proc  1 (counter_process:1) update.pml:28 (state 3)     [local_counters[idx] = (local_counters[idx]+amount)]
177:    proc  1 (counter_process:1) update.pml:31 (state 4)     [((num_updates>=2))]
178:    proc  1 (counter_process:1) update.pml:32 (state 5)     [global_counter = (global_counter+local_counters[idx])]
179:    proc  2 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
180:    proc  2 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
181: proc 2 terminates
182:    proc  1 (counter_process:1) update.pml:33 (state 6)     [local_counters[idx] = 0]
183:    proc  1 (counter_process:1) update.pml:34 (state 7)     [num_updates = 0]
184: proc 1 terminates
185:    proc  0 (:init::1) update.pml:47 (state 12)     [((_nr_pr==1))]
      global_counter = 30
186:    proc  0 (:init::1) update.pml:47 (state 13)     [printf('global_counter = %d\\n',global_counter)]
spin: update.pml:48, Error: assertion violated
spin: text of failed assertion: assert((global_counter<=20))
187:    proc  0 (:init::1) update.pml:48 (state 14)     [assert((global_counter<=20))]
spin: trail ends after 187 steps
#processes: 1
                global_counter = 30
                local_counters[0] = 0
                local_counters[1] = 0
                num_updates = 0
187:    proc  0 (:init::1) update.pml:49 (state 15) <valid end state>
21 processes created
```
