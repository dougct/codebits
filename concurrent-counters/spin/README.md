# Notes

Version of `update` with a bug:

```cpp
// All variables are atomic and local_counters is an array of atomic variables
int64_t update(int64_t amount) {
    // Round-robin updating local counters
    const uint32_t idx = num_updates_++ % num_threads_;
    local_counters_[idx] += amount;
    if (num_updates_ >= threshold_) {
        global_counter_ += local_counters_[idx];
        local_counters_[idx] = 0;
        num_updates_ = 0;
    }
    return global_counter_;
}
```

This version was overcounting in the ApproxCounter because even though the increments are atomic, there could be some thread interleavings which lead to double counting.

I created an equivalent version of the code above in Promela and ran Spin on it (`spin -run update.pml`).

Here's the trace generated by Spin showing that we can indeed overcount if we use the code above:

```
  1:    proc  0 (:init::1) update.pml:54 (state 1)      [i = 1]
  2:    proc  0 (:init::1) update.pml:54 (state 2)      [((i<=2))]
Starting buggy_counter_process with pid 1
  3:    proc  0 (:init::1) update.pml:56 (state 3)      [(run buggy_counter_process(1))]
Starting buggy_counter_process with pid 2
  4:    proc  0 (:init::1) update.pml:57 (state 4)      [(run buggy_counter_process(1))]
  5:    proc  0 (:init::1) update.pml:54 (state 6)      [i = (i+1)]
  6:    proc  0 (:init::1) update.pml:54 (state 2)      [((i<=2))]
Starting buggy_counter_process with pid 3
  7:    proc  0 (:init::1) update.pml:56 (state 3)      [(run buggy_counter_process(1))]
Starting buggy_counter_process with pid 4
  8:    proc  0 (:init::1) update.pml:57 (state 4)      [(run buggy_counter_process(1))]
  9:    proc  0 (:init::1) update.pml:54 (state 6)      [i = (i+1)]
 10:    proc  0 (:init::1) update.pml:59 (state 7)      [else]
 11:    proc  4 (buggy_counter_process:1) update.pml:12 (state 1)       [num_updates = (num_updates+1)]
                num_updates = 1
 12:    proc  4 (buggy_counter_process:1) update.pml:13 (state 2)       [idx = (num_updates%2)]
 13:    proc  4 (buggy_counter_process:1) update.pml:14 (state 3)       [local_counters[idx] = (local_counters[idx]+amount)]
                local_counters[0] = 0
                local_counters[1] = 1
 14:    proc  4 (buggy_counter_process:1) update.pml:24 (state 17)      [else]
 15:    proc  4 (buggy_counter_process:1) update.pml:24 (state 18)      [(1)]
 16: proc 4 terminates
 17:    proc  3 (buggy_counter_process:1) update.pml:12 (state 1)       [num_updates = (num_updates+1)]
                num_updates = 2
 18:    proc  3 (buggy_counter_process:1) update.pml:13 (state 2)       [idx = (num_updates%2)]
 19:    proc  3 (buggy_counter_process:1) update.pml:14 (state 3)       [local_counters[idx] = (local_counters[idx]+amount)]
                local_counters[0] = 1
                local_counters[1] = 1
 20:    proc  3 (buggy_counter_process:1) update.pml:17 (state 4)       [((num_updates>=2))]
 21:    proc  3 (buggy_counter_process:1) update.pml:18 (state 5)       [num_updates = 0]
                num_updates = 0
 22:    proc  3 (buggy_counter_process:1) update.pml:20 (state 6)       [c = 0]
 22:    proc  3 (buggy_counter_process:1) update.pml:20 (state 7)       [c = 0]
 23:    proc  3 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 24:    proc  3 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 1
 25:    proc  3 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
                local_counters[0] = 0
                local_counters[1] = 1
 26:    proc  3 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 27:    proc  3 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 28:    proc  3 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 2
 29:    proc  3 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
                local_counters[0] = 0
                local_counters[1] = 0
 30:    proc  3 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 31:    proc  3 (buggy_counter_process:1) update.pml:23 (state 12)      [else]
 32: proc 3 terminates
 33:    proc  2 (buggy_counter_process:1) update.pml:12 (state 1)       [num_updates = (num_updates+1)]
                num_updates = 1
 34:    proc  2 (buggy_counter_process:1) update.pml:13 (state 2)       [idx = (num_updates%2)]
 35:    proc  2 (buggy_counter_process:1) update.pml:14 (state 3)       [local_counters[idx] = (local_counters[idx]+amount)]
                local_counters[0] = 0
                local_counters[1] = 1
 36:    proc  1 (buggy_counter_process:1) update.pml:12 (state 1)       [num_updates = (num_updates+1)]
                num_updates = 2
 37:    proc  2 (buggy_counter_process:1) update.pml:17 (state 4)       [((num_updates>=2))]
 38:    proc  1 (buggy_counter_process:1) update.pml:13 (state 2)       [idx = (num_updates%2)]
 39:    proc  1 (buggy_counter_process:1) update.pml:14 (state 3)       [local_counters[idx] = (local_counters[idx]+amount)]
                local_counters[0] = 1
                local_counters[1] = 1
 40:    proc  1 (buggy_counter_process:1) update.pml:17 (state 4)       [((num_updates>=2))]
 41:    proc  2 (buggy_counter_process:1) update.pml:18 (state 5)       [num_updates = 0]
                num_updates = 0
 42:    proc  2 (buggy_counter_process:1) update.pml:20 (state 6)       [c = 0]
 42:    proc  2 (buggy_counter_process:1) update.pml:20 (state 7)       [c = 0]
 43:    proc  2 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 44:    proc  2 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 3
 45:    proc  1 (buggy_counter_process:1) update.pml:18 (state 5)       [num_updates = 0]
 46:    proc  1 (buggy_counter_process:1) update.pml:20 (state 6)       [c = 0]
 46:    proc  1 (buggy_counter_process:1) update.pml:20 (state 7)       [c = 0]
 47:    proc  1 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 48:    proc  1 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 4
 49:    proc  2 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
                local_counters[0] = 0
                local_counters[1] = 1
 50:    proc  2 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 51:    proc  2 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 52:    proc  2 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 5
 53:    proc  1 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
 54:    proc  1 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 55:    proc  1 (buggy_counter_process:1) update.pml:20 (state 8)       [((c<=(2-1)))]
 56:    proc  1 (buggy_counter_process:1) update.pml:21 (state 9)       [global_counter = (global_counter+local_counters[c])]
                global_counter = 6
 57:    proc  2 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
                local_counters[0] = 0
                local_counters[1] = 0
 58:    proc  2 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 59:    proc  2 (buggy_counter_process:1) update.pml:23 (state 12)      [else]
 60: proc 2 terminates
 61:    proc  1 (buggy_counter_process:1) update.pml:22 (state 10)      [local_counters[c] = 0]
 62:    proc  1 (buggy_counter_process:1) update.pml:20 (state 11)      [c = (c+1)]
 63:    proc  1 (buggy_counter_process:1) update.pml:23 (state 12)      [else]
 64: proc 1 terminates
 65:    proc  0 (:init::1) update.pml:60 (state 12)     [((_nr_pr==1))]
      global_counter = 6
 66:    proc  0 (:init::1) update.pml:60 (state 13)     [printf('global_counter = %d\\n',global_counter)]
spin: update.pml:61, Error: assertion violated
spin: text of failed assertion: assert((global_counter<=5))
 67:    proc  0 (:init::1) update.pml:61 (state 14)     [assert((global_counter<=5))]
spin: trail ends after 67 steps
#processes: 1
                global_counter = 6
                local_counters[0] = 0
                local_counters[1] = 0
                num_updates = 0
 67:    proc  0 (:init::1) update.pml:62 (state 15) <valid end state>
5 processes created
```
